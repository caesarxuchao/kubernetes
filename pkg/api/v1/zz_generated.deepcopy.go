// +build !ignore_autogenerated

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package v1

import (
	reflect "reflect"

	"k8s.io/api/core/v1"
	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	conversion "k8s.io/apimachinery/pkg/conversion"
	runtime "k8s.io/apimachinery/pkg/runtime"
	types "k8s.io/apimachinery/pkg/types"
)

func init() {
	SchemeBuilder.Register(RegisterDeepCopies)
}

// RegisterDeepCopies adds deep-copy functions to the given scheme. Public
// to allow building arbitrary schemes.
func RegisterDeepCopies(scheme *runtime.Scheme) error {
	return scheme.AddGeneratedDeepCopyFuncs(
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_AWSElasticBlockStoreVolumeSource, InType: reflect.TypeOf(&v1.AWSElasticBlockStoreVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Affinity, InType: reflect.TypeOf(&v1.Affinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_AttachedVolume, InType: reflect.TypeOf(&v1.AttachedVolume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_AvoidPods, InType: reflect.TypeOf(&v1.AvoidPods{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_AzureDiskVolumeSource, InType: reflect.TypeOf(&v1.AzureDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_AzureFileVolumeSource, InType: reflect.TypeOf(&v1.AzureFileVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Binding, InType: reflect.TypeOf(&v1.Binding{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Capabilities, InType: reflect.TypeOf(&v1.Capabilities{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_CephFSVolumeSource, InType: reflect.TypeOf(&v1.CephFSVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_CinderVolumeSource, InType: reflect.TypeOf(&v1.CinderVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ComponentCondition, InType: reflect.TypeOf(&v1.ComponentCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ComponentStatus, InType: reflect.TypeOf(&v1.ComponentStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ComponentStatusList, InType: reflect.TypeOf(&v1.ComponentStatusList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ConfigMap, InType: reflect.TypeOf(&v1.ConfigMap{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ConfigMapEnvSource, InType: reflect.TypeOf(&v1.ConfigMapEnvSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ConfigMapKeySelector, InType: reflect.TypeOf(&v1.ConfigMapKeySelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ConfigMapList, InType: reflect.TypeOf(&v1.ConfigMapList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ConfigMapProjection, InType: reflect.TypeOf(&v1.ConfigMapProjection{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ConfigMapVolumeSource, InType: reflect.TypeOf(&v1.ConfigMapVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Container, InType: reflect.TypeOf(&v1.Container{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ContainerImage, InType: reflect.TypeOf(&v1.ContainerImage{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ContainerPort, InType: reflect.TypeOf(&v1.ContainerPort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ContainerState, InType: reflect.TypeOf(&v1.ContainerState{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ContainerStateRunning, InType: reflect.TypeOf(&v1.ContainerStateRunning{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ContainerStateTerminated, InType: reflect.TypeOf(&v1.ContainerStateTerminated{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ContainerStateWaiting, InType: reflect.TypeOf(&v1.ContainerStateWaiting{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ContainerStatus, InType: reflect.TypeOf(&v1.ContainerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_DaemonEndpoint, InType: reflect.TypeOf(&v1.DaemonEndpoint{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_DeleteOptions, InType: reflect.TypeOf(&v1.DeleteOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_DownwardAPIProjection, InType: reflect.TypeOf(&v1.DownwardAPIProjection{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_DownwardAPIVolumeFile, InType: reflect.TypeOf(&v1.DownwardAPIVolumeFile{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_DownwardAPIVolumeSource, InType: reflect.TypeOf(&v1.DownwardAPIVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EmptyDirVolumeSource, InType: reflect.TypeOf(&v1.EmptyDirVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EndpointAddress, InType: reflect.TypeOf(&v1.EndpointAddress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EndpointPort, InType: reflect.TypeOf(&v1.EndpointPort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EndpointSubset, InType: reflect.TypeOf(&v1.EndpointSubset{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Endpoints, InType: reflect.TypeOf(&v1.Endpoints{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EndpointsList, InType: reflect.TypeOf(&v1.EndpointsList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EnvFromSource, InType: reflect.TypeOf(&v1.EnvFromSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EnvVar, InType: reflect.TypeOf(&v1.EnvVar{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EnvVarSource, InType: reflect.TypeOf(&v1.EnvVarSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Event, InType: reflect.TypeOf(&v1.Event{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EventList, InType: reflect.TypeOf(&v1.EventList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_EventSource, InType: reflect.TypeOf(&v1.EventSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ExecAction, InType: reflect.TypeOf(&v1.ExecAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_FCVolumeSource, InType: reflect.TypeOf(&v1.FCVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_FlexVolumeSource, InType: reflect.TypeOf(&v1.FlexVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_FlockerVolumeSource, InType: reflect.TypeOf(&v1.FlockerVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_GCEPersistentDiskVolumeSource, InType: reflect.TypeOf(&v1.GCEPersistentDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_GitRepoVolumeSource, InType: reflect.TypeOf(&v1.GitRepoVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_GlusterfsVolumeSource, InType: reflect.TypeOf(&v1.GlusterfsVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_HTTPGetAction, InType: reflect.TypeOf(&v1.HTTPGetAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_HTTPHeader, InType: reflect.TypeOf(&v1.HTTPHeader{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Handler, InType: reflect.TypeOf(&v1.Handler{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_HostPathVolumeSource, InType: reflect.TypeOf(&v1.HostPathVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ISCSIVolumeSource, InType: reflect.TypeOf(&v1.ISCSIVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_KeyToPath, InType: reflect.TypeOf(&v1.KeyToPath{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Lifecycle, InType: reflect.TypeOf(&v1.Lifecycle{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_LimitRange, InType: reflect.TypeOf(&v1.LimitRange{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_LimitRangeItem, InType: reflect.TypeOf(&v1.LimitRangeItem{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_LimitRangeList, InType: reflect.TypeOf(&v1.LimitRangeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_LimitRangeSpec, InType: reflect.TypeOf(&v1.LimitRangeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_List, InType: reflect.TypeOf(&v1.List{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ListOptions, InType: reflect.TypeOf(&v1.ListOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_LoadBalancerIngress, InType: reflect.TypeOf(&v1.LoadBalancerIngress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_LoadBalancerStatus, InType: reflect.TypeOf(&v1.LoadBalancerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_LocalObjectReference, InType: reflect.TypeOf(&v1.LocalObjectReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NFSVolumeSource, InType: reflect.TypeOf(&v1.NFSVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Namespace, InType: reflect.TypeOf(&v1.Namespace{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NamespaceList, InType: reflect.TypeOf(&v1.NamespaceList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NamespaceSpec, InType: reflect.TypeOf(&v1.NamespaceSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NamespaceStatus, InType: reflect.TypeOf(&v1.NamespaceStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Node, InType: reflect.TypeOf(&v1.Node{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeAddress, InType: reflect.TypeOf(&v1.NodeAddress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeAffinity, InType: reflect.TypeOf(&v1.NodeAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeCondition, InType: reflect.TypeOf(&v1.NodeCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeDaemonEndpoints, InType: reflect.TypeOf(&v1.NodeDaemonEndpoints{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeList, InType: reflect.TypeOf(&v1.NodeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeProxyOptions, InType: reflect.TypeOf(&v1.NodeProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeResources, InType: reflect.TypeOf(&v1.NodeResources{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeSelector, InType: reflect.TypeOf(&v1.NodeSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeSelectorRequirement, InType: reflect.TypeOf(&v1.NodeSelectorRequirement{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeSelectorTerm, InType: reflect.TypeOf(&v1.NodeSelectorTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeSpec, InType: reflect.TypeOf(&v1.NodeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeStatus, InType: reflect.TypeOf(&v1.NodeStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_NodeSystemInfo, InType: reflect.TypeOf(&v1.NodeSystemInfo{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ObjectFieldSelector, InType: reflect.TypeOf(&v1.ObjectFieldSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ObjectMeta, InType: reflect.TypeOf(&v1.ObjectMeta{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ObjectReference, InType: reflect.TypeOf(&v1.ObjectReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolume, InType: reflect.TypeOf(&v1.PersistentVolume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeClaim, InType: reflect.TypeOf(&v1.PersistentVolumeClaim{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeClaimList, InType: reflect.TypeOf(&v1.PersistentVolumeClaimList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeClaimSpec, InType: reflect.TypeOf(&v1.PersistentVolumeClaimSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeClaimStatus, InType: reflect.TypeOf(&v1.PersistentVolumeClaimStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeClaimVolumeSource, InType: reflect.TypeOf(&v1.PersistentVolumeClaimVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeList, InType: reflect.TypeOf(&v1.PersistentVolumeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeSource, InType: reflect.TypeOf(&v1.PersistentVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeSpec, InType: reflect.TypeOf(&v1.PersistentVolumeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PersistentVolumeStatus, InType: reflect.TypeOf(&v1.PersistentVolumeStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PhotonPersistentDiskVolumeSource, InType: reflect.TypeOf(&v1.PhotonPersistentDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Pod, InType: reflect.TypeOf(&v1.Pod{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodAffinity, InType: reflect.TypeOf(&v1.PodAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodAffinityTerm, InType: reflect.TypeOf(&v1.PodAffinityTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodAntiAffinity, InType: reflect.TypeOf(&v1.PodAntiAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodAttachOptions, InType: reflect.TypeOf(&v1.PodAttachOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodCondition, InType: reflect.TypeOf(&v1.PodCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodExecOptions, InType: reflect.TypeOf(&v1.PodExecOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodList, InType: reflect.TypeOf(&v1.PodList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodLogOptions, InType: reflect.TypeOf(&v1.PodLogOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodPortForwardOptions, InType: reflect.TypeOf(&v1.PodPortForwardOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodProxyOptions, InType: reflect.TypeOf(&v1.PodProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodSecurityContext, InType: reflect.TypeOf(&v1.PodSecurityContext{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodSignature, InType: reflect.TypeOf(&v1.PodSignature{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodSpec, InType: reflect.TypeOf(&v1.PodSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodStatus, InType: reflect.TypeOf(&v1.PodStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodStatusResult, InType: reflect.TypeOf(&v1.PodStatusResult{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodTemplate, InType: reflect.TypeOf(&v1.PodTemplate{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodTemplateList, InType: reflect.TypeOf(&v1.PodTemplateList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PodTemplateSpec, InType: reflect.TypeOf(&v1.PodTemplateSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PortworxVolumeSource, InType: reflect.TypeOf(&v1.PortworxVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Preconditions, InType: reflect.TypeOf(&v1.Preconditions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PreferAvoidPodsEntry, InType: reflect.TypeOf(&v1.PreferAvoidPodsEntry{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_PreferredSchedulingTerm, InType: reflect.TypeOf(&v1.PreferredSchedulingTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Probe, InType: reflect.TypeOf(&v1.Probe{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ProjectedVolumeSource, InType: reflect.TypeOf(&v1.ProjectedVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_QuobyteVolumeSource, InType: reflect.TypeOf(&v1.QuobyteVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_RBDVolumeSource, InType: reflect.TypeOf(&v1.RBDVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_RangeAllocation, InType: reflect.TypeOf(&v1.RangeAllocation{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ReplicationController, InType: reflect.TypeOf(&v1.ReplicationController{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ReplicationControllerCondition, InType: reflect.TypeOf(&v1.ReplicationControllerCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ReplicationControllerList, InType: reflect.TypeOf(&v1.ReplicationControllerList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ReplicationControllerSpec, InType: reflect.TypeOf(&v1.ReplicationControllerSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ReplicationControllerStatus, InType: reflect.TypeOf(&v1.ReplicationControllerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ResourceFieldSelector, InType: reflect.TypeOf(&v1.ResourceFieldSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ResourceQuota, InType: reflect.TypeOf(&v1.ResourceQuota{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ResourceQuotaList, InType: reflect.TypeOf(&v1.ResourceQuotaList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ResourceQuotaSpec, InType: reflect.TypeOf(&v1.ResourceQuotaSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ResourceQuotaStatus, InType: reflect.TypeOf(&v1.ResourceQuotaStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ResourceRequirements, InType: reflect.TypeOf(&v1.ResourceRequirements{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_SELinuxOptions, InType: reflect.TypeOf(&v1.SELinuxOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ScaleIOVolumeSource, InType: reflect.TypeOf(&v1.ScaleIOVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Secret, InType: reflect.TypeOf(&v1.Secret{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_SecretEnvSource, InType: reflect.TypeOf(&v1.SecretEnvSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_SecretKeySelector, InType: reflect.TypeOf(&v1.SecretKeySelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_SecretList, InType: reflect.TypeOf(&v1.SecretList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_SecretProjection, InType: reflect.TypeOf(&v1.SecretProjection{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_SecretVolumeSource, InType: reflect.TypeOf(&v1.SecretVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_SecurityContext, InType: reflect.TypeOf(&v1.SecurityContext{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_SerializedReference, InType: reflect.TypeOf(&v1.SerializedReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Service, InType: reflect.TypeOf(&v1.Service{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ServiceAccount, InType: reflect.TypeOf(&v1.ServiceAccount{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ServiceAccountList, InType: reflect.TypeOf(&v1.ServiceAccountList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ServiceList, InType: reflect.TypeOf(&v1.ServiceList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ServicePort, InType: reflect.TypeOf(&v1.ServicePort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ServiceProxyOptions, InType: reflect.TypeOf(&v1.ServiceProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ServiceSpec, InType: reflect.TypeOf(&v1.ServiceSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_ServiceStatus, InType: reflect.TypeOf(&v1.ServiceStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Sysctl, InType: reflect.TypeOf(&v1.Sysctl{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_TCPSocketAction, InType: reflect.TypeOf(&v1.TCPSocketAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Taint, InType: reflect.TypeOf(&v1.Taint{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Toleration, InType: reflect.TypeOf(&v1.Toleration{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_Volume, InType: reflect.TypeOf(&v1.Volume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_VolumeMount, InType: reflect.TypeOf(&v1.VolumeMount{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_VolumeProjection, InType: reflect.TypeOf(&v1.VolumeProjection{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_VolumeSource, InType: reflect.TypeOf(&v1.VolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_VsphereVirtualDiskVolumeSource, InType: reflect.TypeOf(&v1.VsphereVirtualDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_v1_WeightedPodAffinityTerm, InType: reflect.TypeOf(&v1.WeightedPodAffinityTerm{})},
	)
}

func DeepCopy_v1_AWSElasticBlockStoreVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.AWSElasticBlockStoreVolumeSource)
		out := out.(*v1.AWSElasticBlockStoreVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Affinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Affinity)
		out := out.(*v1.Affinity)
		*out = *in
		if in.NodeAffinity != nil {
			in, out := &in.NodeAffinity, &out.NodeAffinity
			*out = new(v1.NodeAffinity)
			if err := DeepCopy_v1_NodeAffinity(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PodAffinity != nil {
			in, out := &in.PodAffinity, &out.PodAffinity
			*out = new(v1.PodAffinity)
			if err := DeepCopy_v1_PodAffinity(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PodAntiAffinity != nil {
			in, out := &in.PodAntiAffinity, &out.PodAntiAffinity
			*out = new(v1.PodAntiAffinity)
			if err := DeepCopy_v1_PodAntiAffinity(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_AttachedVolume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.AttachedVolume)
		out := out.(*v1.AttachedVolume)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_AvoidPods(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.AvoidPods)
		out := out.(*v1.AvoidPods)
		*out = *in
		if in.PreferAvoidPods != nil {
			in, out := &in.PreferAvoidPods, &out.PreferAvoidPods
			*out = make([]v1.PreferAvoidPodsEntry, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_PreferAvoidPodsEntry(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_AzureDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.AzureDiskVolumeSource)
		out := out.(*v1.AzureDiskVolumeSource)
		*out = *in
		if in.CachingMode != nil {
			in, out := &in.CachingMode, &out.CachingMode
			*out = new(v1.AzureDataDiskCachingMode)
			**out = **in
		}
		if in.FSType != nil {
			in, out := &in.FSType, &out.FSType
			*out = new(string)
			**out = **in
		}
		if in.ReadOnly != nil {
			in, out := &in.ReadOnly, &out.ReadOnly
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_AzureFileVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.AzureFileVolumeSource)
		out := out.(*v1.AzureFileVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Binding(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Binding)
		out := out.(*v1.Binding)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		return nil
	}
}

func DeepCopy_v1_Capabilities(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Capabilities)
		out := out.(*v1.Capabilities)
		*out = *in
		if in.Add != nil {
			in, out := &in.Add, &out.Add
			*out = make([]v1.Capability, len(*in))
			copy(*out, *in)
		}
		if in.Drop != nil {
			in, out := &in.Drop, &out.Drop
			*out = make([]v1.Capability, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_CephFSVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.CephFSVolumeSource)
		out := out.(*v1.CephFSVolumeSource)
		*out = *in
		if in.Monitors != nil {
			in, out := &in.Monitors, &out.Monitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(v1.LocalObjectReference)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_CinderVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.CinderVolumeSource)
		out := out.(*v1.CinderVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ComponentCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ComponentCondition)
		out := out.(*v1.ComponentCondition)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ComponentStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ComponentStatus)
		out := out.(*v1.ComponentStatus)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]v1.ComponentCondition, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_ComponentStatusList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ComponentStatusList)
		out := out.(*v1.ComponentStatusList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.ComponentStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ComponentStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_ConfigMap(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ConfigMap)
		out := out.(*v1.ConfigMap)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		return nil
	}
}

func DeepCopy_v1_ConfigMapEnvSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ConfigMapEnvSource)
		out := out.(*v1.ConfigMapEnvSource)
		*out = *in
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_ConfigMapKeySelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ConfigMapKeySelector)
		out := out.(*v1.ConfigMapKeySelector)
		*out = *in
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_ConfigMapList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ConfigMapList)
		out := out.(*v1.ConfigMapList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.ConfigMap, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ConfigMap(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_ConfigMapProjection(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ConfigMapProjection)
		out := out.(*v1.ConfigMapProjection)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_ConfigMapVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ConfigMapVolumeSource)
		out := out.(*v1.ConfigMapVolumeSource)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		}
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_Container(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Container)
		out := out.(*v1.Container)
		*out = *in
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.Args != nil {
			in, out := &in.Args, &out.Args
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]v1.ContainerPort, len(*in))
			copy(*out, *in)
		}
		if in.EnvFrom != nil {
			in, out := &in.EnvFrom, &out.EnvFrom
			*out = make([]v1.EnvFromSource, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_EnvFromSource(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Env != nil {
			in, out := &in.Env, &out.Env
			*out = make([]v1.EnvVar, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_EnvVar(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if err := DeepCopy_v1_ResourceRequirements(&in.Resources, &out.Resources, c); err != nil {
			return err
		}
		if in.VolumeMounts != nil {
			in, out := &in.VolumeMounts, &out.VolumeMounts
			*out = make([]v1.VolumeMount, len(*in))
			copy(*out, *in)
		}
		if in.LivenessProbe != nil {
			in, out := &in.LivenessProbe, &out.LivenessProbe
			*out = new(v1.Probe)
			if err := DeepCopy_v1_Probe(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ReadinessProbe != nil {
			in, out := &in.ReadinessProbe, &out.ReadinessProbe
			*out = new(v1.Probe)
			if err := DeepCopy_v1_Probe(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Lifecycle != nil {
			in, out := &in.Lifecycle, &out.Lifecycle
			*out = new(v1.Lifecycle)
			if err := DeepCopy_v1_Lifecycle(*in, *out, c); err != nil {
				return err
			}
		}
		if in.SecurityContext != nil {
			in, out := &in.SecurityContext, &out.SecurityContext
			*out = new(v1.SecurityContext)
			if err := DeepCopy_v1_SecurityContext(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_ContainerImage(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ContainerImage)
		out := out.(*v1.ContainerImage)
		*out = *in
		if in.Names != nil {
			in, out := &in.Names, &out.Names
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_ContainerPort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ContainerPort)
		out := out.(*v1.ContainerPort)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ContainerState(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ContainerState)
		out := out.(*v1.ContainerState)
		*out = *in
		if in.Waiting != nil {
			in, out := &in.Waiting, &out.Waiting
			*out = new(v1.ContainerStateWaiting)
			**out = **in
		}
		if in.Running != nil {
			in, out := &in.Running, &out.Running
			*out = new(v1.ContainerStateRunning)
			if err := DeepCopy_v1_ContainerStateRunning(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Terminated != nil {
			in, out := &in.Terminated, &out.Terminated
			*out = new(v1.ContainerStateTerminated)
			if err := DeepCopy_v1_ContainerStateTerminated(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_ContainerStateRunning(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ContainerStateRunning)
		out := out.(*v1.ContainerStateRunning)
		*out = *in
		out.StartedAt = in.StartedAt.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_ContainerStateTerminated(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ContainerStateTerminated)
		out := out.(*v1.ContainerStateTerminated)
		*out = *in
		out.StartedAt = in.StartedAt.DeepCopy()
		out.FinishedAt = in.FinishedAt.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_ContainerStateWaiting(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ContainerStateWaiting)
		out := out.(*v1.ContainerStateWaiting)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ContainerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ContainerStatus)
		out := out.(*v1.ContainerStatus)
		*out = *in
		if err := DeepCopy_v1_ContainerState(&in.State, &out.State, c); err != nil {
			return err
		}
		if err := DeepCopy_v1_ContainerState(&in.LastTerminationState, &out.LastTerminationState, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_DaemonEndpoint(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.DaemonEndpoint)
		out := out.(*v1.DaemonEndpoint)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_DeleteOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.DeleteOptions)
		out := out.(*v1.DeleteOptions)
		*out = *in
		if in.GracePeriodSeconds != nil {
			in, out := &in.GracePeriodSeconds, &out.GracePeriodSeconds
			*out = new(int64)
			**out = **in
		}
		if in.Preconditions != nil {
			in, out := &in.Preconditions, &out.Preconditions
			*out = new(v1.Preconditions)
			if err := DeepCopy_v1_Preconditions(*in, *out, c); err != nil {
				return err
			}
		}
		if in.OrphanDependents != nil {
			in, out := &in.OrphanDependents, &out.OrphanDependents
			*out = new(bool)
			**out = **in
		}
		if in.PropagationPolicy != nil {
			in, out := &in.PropagationPolicy, &out.PropagationPolicy
			*out = new(v1.DeletionPropagation)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_DownwardAPIProjection(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.DownwardAPIProjection)
		out := out.(*v1.DownwardAPIProjection)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.DownwardAPIVolumeFile, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_DownwardAPIVolumeFile(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_DownwardAPIVolumeFile(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.DownwardAPIVolumeFile)
		out := out.(*v1.DownwardAPIVolumeFile)
		*out = *in
		if in.FieldRef != nil {
			in, out := &in.FieldRef, &out.FieldRef
			*out = new(v1.ObjectFieldSelector)
			**out = **in
		}
		if in.ResourceFieldRef != nil {
			in, out := &in.ResourceFieldRef, &out.ResourceFieldRef
			*out = new(v1.ResourceFieldSelector)
			if err := DeepCopy_v1_ResourceFieldSelector(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Mode != nil {
			in, out := &in.Mode, &out.Mode
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_DownwardAPIVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.DownwardAPIVolumeSource)
		out := out.(*v1.DownwardAPIVolumeSource)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.DownwardAPIVolumeFile, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_DownwardAPIVolumeFile(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_EmptyDirVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EmptyDirVolumeSource)
		out := out.(*v1.EmptyDirVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_EndpointAddress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EndpointAddress)
		out := out.(*v1.EndpointAddress)
		*out = *in
		if in.NodeName != nil {
			in, out := &in.NodeName, &out.NodeName
			*out = new(string)
			**out = **in
		}
		if in.TargetRef != nil {
			in, out := &in.TargetRef, &out.TargetRef
			*out = new(v1.ObjectReference)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_EndpointPort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EndpointPort)
		out := out.(*v1.EndpointPort)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_EndpointSubset(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EndpointSubset)
		out := out.(*v1.EndpointSubset)
		*out = *in
		if in.Addresses != nil {
			in, out := &in.Addresses, &out.Addresses
			*out = make([]v1.EndpointAddress, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_EndpointAddress(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.NotReadyAddresses != nil {
			in, out := &in.NotReadyAddresses, &out.NotReadyAddresses
			*out = make([]v1.EndpointAddress, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_EndpointAddress(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]v1.EndpointPort, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_Endpoints(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Endpoints)
		out := out.(*v1.Endpoints)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if in.Subsets != nil {
			in, out := &in.Subsets, &out.Subsets
			*out = make([]v1.EndpointSubset, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_EndpointSubset(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_EndpointsList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EndpointsList)
		out := out.(*v1.EndpointsList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.Endpoints, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Endpoints(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_EnvFromSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EnvFromSource)
		out := out.(*v1.EnvFromSource)
		*out = *in
		if in.ConfigMapRef != nil {
			in, out := &in.ConfigMapRef, &out.ConfigMapRef
			*out = new(v1.ConfigMapEnvSource)
			if err := DeepCopy_v1_ConfigMapEnvSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(v1.SecretEnvSource)
			if err := DeepCopy_v1_SecretEnvSource(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_EnvVar(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EnvVar)
		out := out.(*v1.EnvVar)
		*out = *in
		if in.ValueFrom != nil {
			in, out := &in.ValueFrom, &out.ValueFrom
			*out = new(v1.EnvVarSource)
			if err := DeepCopy_v1_EnvVarSource(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_EnvVarSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EnvVarSource)
		out := out.(*v1.EnvVarSource)
		*out = *in
		if in.FieldRef != nil {
			in, out := &in.FieldRef, &out.FieldRef
			*out = new(v1.ObjectFieldSelector)
			**out = **in
		}
		if in.ResourceFieldRef != nil {
			in, out := &in.ResourceFieldRef, &out.ResourceFieldRef
			*out = new(v1.ResourceFieldSelector)
			if err := DeepCopy_v1_ResourceFieldSelector(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ConfigMapKeyRef != nil {
			in, out := &in.ConfigMapKeyRef, &out.ConfigMapKeyRef
			*out = new(v1.ConfigMapKeySelector)
			if err := DeepCopy_v1_ConfigMapKeySelector(*in, *out, c); err != nil {
				return err
			}
		}
		if in.SecretKeyRef != nil {
			in, out := &in.SecretKeyRef, &out.SecretKeyRef
			*out = new(v1.SecretKeySelector)
			if err := DeepCopy_v1_SecretKeySelector(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_Event(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Event)
		out := out.(*v1.Event)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		out.FirstTimestamp = in.FirstTimestamp.DeepCopy()
		out.LastTimestamp = in.LastTimestamp.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_EventList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EventList)
		out := out.(*v1.EventList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.Event, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Event(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_EventSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.EventSource)
		out := out.(*v1.EventSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ExecAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ExecAction)
		out := out.(*v1.ExecAction)
		*out = *in
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_FCVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.FCVolumeSource)
		out := out.(*v1.FCVolumeSource)
		*out = *in
		if in.TargetWWNs != nil {
			in, out := &in.TargetWWNs, &out.TargetWWNs
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.Lun != nil {
			in, out := &in.Lun, &out.Lun
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_FlexVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.FlexVolumeSource)
		out := out.(*v1.FlexVolumeSource)
		*out = *in
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(v1.LocalObjectReference)
			**out = **in
		}
		if in.Options != nil {
			in, out := &in.Options, &out.Options
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		return nil
	}
}

func DeepCopy_v1_FlockerVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.FlockerVolumeSource)
		out := out.(*v1.FlockerVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_GCEPersistentDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.GCEPersistentDiskVolumeSource)
		out := out.(*v1.GCEPersistentDiskVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_GitRepoVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.GitRepoVolumeSource)
		out := out.(*v1.GitRepoVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_GlusterfsVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.GlusterfsVolumeSource)
		out := out.(*v1.GlusterfsVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_HTTPGetAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.HTTPGetAction)
		out := out.(*v1.HTTPGetAction)
		*out = *in
		if in.HTTPHeaders != nil {
			in, out := &in.HTTPHeaders, &out.HTTPHeaders
			*out = make([]v1.HTTPHeader, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_HTTPHeader(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.HTTPHeader)
		out := out.(*v1.HTTPHeader)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Handler(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Handler)
		out := out.(*v1.Handler)
		*out = *in
		if in.Exec != nil {
			in, out := &in.Exec, &out.Exec
			*out = new(v1.ExecAction)
			if err := DeepCopy_v1_ExecAction(*in, *out, c); err != nil {
				return err
			}
		}
		if in.HTTPGet != nil {
			in, out := &in.HTTPGet, &out.HTTPGet
			*out = new(v1.HTTPGetAction)
			if err := DeepCopy_v1_HTTPGetAction(*in, *out, c); err != nil {
				return err
			}
		}
		if in.TCPSocket != nil {
			in, out := &in.TCPSocket, &out.TCPSocket
			*out = new(v1.TCPSocketAction)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_HostPathVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.HostPathVolumeSource)
		out := out.(*v1.HostPathVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ISCSIVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ISCSIVolumeSource)
		out := out.(*v1.ISCSIVolumeSource)
		*out = *in
		if in.Portals != nil {
			in, out := &in.Portals, &out.Portals
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(v1.LocalObjectReference)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_KeyToPath(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.KeyToPath)
		out := out.(*v1.KeyToPath)
		*out = *in
		if in.Mode != nil {
			in, out := &in.Mode, &out.Mode
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_Lifecycle(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Lifecycle)
		out := out.(*v1.Lifecycle)
		*out = *in
		if in.PostStart != nil {
			in, out := &in.PostStart, &out.PostStart
			*out = new(v1.Handler)
			if err := DeepCopy_v1_Handler(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PreStop != nil {
			in, out := &in.PreStop, &out.PreStop
			*out = new(v1.Handler)
			if err := DeepCopy_v1_Handler(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_LimitRange(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.LimitRange)
		out := out.(*v1.LimitRange)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_LimitRangeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_LimitRangeItem(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.LimitRangeItem)
		out := out.(*v1.LimitRangeItem)
		*out = *in
		if in.Max != nil {
			in, out := &in.Max, &out.Max
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Min != nil {
			in, out := &in.Min, &out.Min
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Default != nil {
			in, out := &in.Default, &out.Default
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.DefaultRequest != nil {
			in, out := &in.DefaultRequest, &out.DefaultRequest
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.MaxLimitRequestRatio != nil {
			in, out := &in.MaxLimitRequestRatio, &out.MaxLimitRequestRatio
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

func DeepCopy_v1_LimitRangeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.LimitRangeList)
		out := out.(*v1.LimitRangeList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.LimitRange, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_LimitRange(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_LimitRangeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.LimitRangeSpec)
		out := out.(*v1.LimitRangeSpec)
		*out = *in
		if in.Limits != nil {
			in, out := &in.Limits, &out.Limits
			*out = make([]v1.LimitRangeItem, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_LimitRangeItem(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_List(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.List)
		out := out.(*v1.List)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]runtime.RawExtension, len(*in))
			for i := range *in {
				if newVal, err := c.DeepCopy(&(*in)[i]); err != nil {
					return err
				} else {
					(*out)[i] = *newVal.(*runtime.RawExtension)
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_ListOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ListOptions)
		out := out.(*v1.ListOptions)
		*out = *in
		if in.TimeoutSeconds != nil {
			in, out := &in.TimeoutSeconds, &out.TimeoutSeconds
			*out = new(int64)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_LoadBalancerIngress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.LoadBalancerIngress)
		out := out.(*v1.LoadBalancerIngress)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_LoadBalancerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.LoadBalancerStatus)
		out := out.(*v1.LoadBalancerStatus)
		*out = *in
		if in.Ingress != nil {
			in, out := &in.Ingress, &out.Ingress
			*out = make([]v1.LoadBalancerIngress, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_LocalObjectReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.LocalObjectReference)
		out := out.(*v1.LocalObjectReference)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_NFSVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NFSVolumeSource)
		out := out.(*v1.NFSVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Namespace(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Namespace)
		out := out.(*v1.Namespace)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_NamespaceSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_NamespaceList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NamespaceList)
		out := out.(*v1.NamespaceList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.Namespace, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Namespace(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_NamespaceSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NamespaceSpec)
		out := out.(*v1.NamespaceSpec)
		*out = *in
		if in.Finalizers != nil {
			in, out := &in.Finalizers, &out.Finalizers
			*out = make([]v1.FinalizerName, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_NamespaceStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NamespaceStatus)
		out := out.(*v1.NamespaceStatus)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Node(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Node)
		out := out.(*v1.Node)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_NodeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_v1_NodeStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_NodeAddress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeAddress)
		out := out.(*v1.NodeAddress)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_NodeAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeAffinity)
		out := out.(*v1.NodeAffinity)
		*out = *in
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = new(v1.NodeSelector)
			if err := DeepCopy_v1_NodeSelector(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]v1.PreferredSchedulingTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_PreferredSchedulingTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_NodeCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeCondition)
		out := out.(*v1.NodeCondition)
		*out = *in
		out.LastHeartbeatTime = in.LastHeartbeatTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_NodeDaemonEndpoints(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeDaemonEndpoints)
		out := out.(*v1.NodeDaemonEndpoints)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_NodeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeList)
		out := out.(*v1.NodeList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.Node, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Node(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_NodeProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeProxyOptions)
		out := out.(*v1.NodeProxyOptions)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_NodeResources(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeResources)
		out := out.(*v1.NodeResources)
		*out = *in
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

func DeepCopy_v1_NodeSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeSelector)
		out := out.(*v1.NodeSelector)
		*out = *in
		if in.NodeSelectorTerms != nil {
			in, out := &in.NodeSelectorTerms, &out.NodeSelectorTerms
			*out = make([]v1.NodeSelectorTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_NodeSelectorTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_NodeSelectorRequirement(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeSelectorRequirement)
		out := out.(*v1.NodeSelectorRequirement)
		*out = *in
		if in.Values != nil {
			in, out := &in.Values, &out.Values
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_NodeSelectorTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeSelectorTerm)
		out := out.(*v1.NodeSelectorTerm)
		*out = *in
		if in.MatchExpressions != nil {
			in, out := &in.MatchExpressions, &out.MatchExpressions
			*out = make([]v1.NodeSelectorRequirement, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_NodeSelectorRequirement(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_NodeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeSpec)
		out := out.(*v1.NodeSpec)
		*out = *in
		if in.Taints != nil {
			in, out := &in.Taints, &out.Taints
			*out = make([]v1.Taint, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Taint(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_NodeStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeStatus)
		out := out.(*v1.NodeStatus)
		*out = *in
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Allocatable != nil {
			in, out := &in.Allocatable, &out.Allocatable
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]v1.NodeCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_NodeCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Addresses != nil {
			in, out := &in.Addresses, &out.Addresses
			*out = make([]v1.NodeAddress, len(*in))
			copy(*out, *in)
		}
		if in.Images != nil {
			in, out := &in.Images, &out.Images
			*out = make([]v1.ContainerImage, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ContainerImage(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.VolumesInUse != nil {
			in, out := &in.VolumesInUse, &out.VolumesInUse
			*out = make([]v1.UniqueVolumeName, len(*in))
			copy(*out, *in)
		}
		if in.VolumesAttached != nil {
			in, out := &in.VolumesAttached, &out.VolumesAttached
			*out = make([]v1.AttachedVolume, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_NodeSystemInfo(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.NodeSystemInfo)
		out := out.(*v1.NodeSystemInfo)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ObjectFieldSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ObjectFieldSelector)
		out := out.(*v1.ObjectFieldSelector)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ObjectMeta(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ObjectMeta)
		out := out.(*v1.ObjectMeta)
		*out = *in
		out.CreationTimestamp = in.CreationTimestamp.DeepCopy()
		if in.DeletionTimestamp != nil {
			in, out := &in.DeletionTimestamp, &out.DeletionTimestamp
			*out = new(meta_v1.Time)
			**out = (*in).DeepCopy()
		}
		if in.DeletionGracePeriodSeconds != nil {
			in, out := &in.DeletionGracePeriodSeconds, &out.DeletionGracePeriodSeconds
			*out = new(int64)
			**out = **in
		}
		if in.Labels != nil {
			in, out := &in.Labels, &out.Labels
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.Annotations != nil {
			in, out := &in.Annotations, &out.Annotations
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.OwnerReferences != nil {
			in, out := &in.OwnerReferences, &out.OwnerReferences
			*out = make([]meta_v1.OwnerReference, len(*in))
			for i := range *in {
				if newVal, err := c.DeepCopy(&(*in)[i]); err != nil {
					return err
				} else {
					(*out)[i] = *newVal.(*meta_v1.OwnerReference)
				}
			}
		}
		if in.Finalizers != nil {
			in, out := &in.Finalizers, &out.Finalizers
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_ObjectReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ObjectReference)
		out := out.(*v1.ObjectReference)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_PersistentVolume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolume)
		out := out.(*v1.PersistentVolume)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_PersistentVolumeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeClaim(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeClaim)
		out := out.(*v1.PersistentVolumeClaim)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_PersistentVolumeClaimSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_v1_PersistentVolumeClaimStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeClaimList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeClaimList)
		out := out.(*v1.PersistentVolumeClaimList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.PersistentVolumeClaim, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_PersistentVolumeClaim(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeClaimSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeClaimSpec)
		out := out.(*v1.PersistentVolumeClaimSpec)
		*out = *in
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]v1.PersistentVolumeAccessMode, len(*in))
			copy(*out, *in)
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			if newVal, err := c.DeepCopy(*in); err != nil {
				return err
			} else {
				*out = newVal.(*meta_v1.LabelSelector)
			}
		}
		if err := DeepCopy_v1_ResourceRequirements(&in.Resources, &out.Resources, c); err != nil {
			return err
		}
		if in.StorageClassName != nil {
			in, out := &in.StorageClassName, &out.StorageClassName
			*out = new(string)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeClaimStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeClaimStatus)
		out := out.(*v1.PersistentVolumeClaimStatus)
		*out = *in
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]v1.PersistentVolumeAccessMode, len(*in))
			copy(*out, *in)
		}
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeClaimVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeClaimVolumeSource)
		out := out.(*v1.PersistentVolumeClaimVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeList)
		out := out.(*v1.PersistentVolumeList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.PersistentVolume, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_PersistentVolume(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeSource)
		out := out.(*v1.PersistentVolumeSource)
		*out = *in
		if in.GCEPersistentDisk != nil {
			in, out := &in.GCEPersistentDisk, &out.GCEPersistentDisk
			*out = new(v1.GCEPersistentDiskVolumeSource)
			**out = **in
		}
		if in.AWSElasticBlockStore != nil {
			in, out := &in.AWSElasticBlockStore, &out.AWSElasticBlockStore
			*out = new(v1.AWSElasticBlockStoreVolumeSource)
			**out = **in
		}
		if in.HostPath != nil {
			in, out := &in.HostPath, &out.HostPath
			*out = new(v1.HostPathVolumeSource)
			**out = **in
		}
		if in.Glusterfs != nil {
			in, out := &in.Glusterfs, &out.Glusterfs
			*out = new(v1.GlusterfsVolumeSource)
			**out = **in
		}
		if in.NFS != nil {
			in, out := &in.NFS, &out.NFS
			*out = new(v1.NFSVolumeSource)
			**out = **in
		}
		if in.RBD != nil {
			in, out := &in.RBD, &out.RBD
			*out = new(v1.RBDVolumeSource)
			if err := DeepCopy_v1_RBDVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ISCSI != nil {
			in, out := &in.ISCSI, &out.ISCSI
			*out = new(v1.ISCSIVolumeSource)
			if err := DeepCopy_v1_ISCSIVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Cinder != nil {
			in, out := &in.Cinder, &out.Cinder
			*out = new(v1.CinderVolumeSource)
			**out = **in
		}
		if in.CephFS != nil {
			in, out := &in.CephFS, &out.CephFS
			*out = new(v1.CephFSVolumeSource)
			if err := DeepCopy_v1_CephFSVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.FC != nil {
			in, out := &in.FC, &out.FC
			*out = new(v1.FCVolumeSource)
			if err := DeepCopy_v1_FCVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Flocker != nil {
			in, out := &in.Flocker, &out.Flocker
			*out = new(v1.FlockerVolumeSource)
			**out = **in
		}
		if in.FlexVolume != nil {
			in, out := &in.FlexVolume, &out.FlexVolume
			*out = new(v1.FlexVolumeSource)
			if err := DeepCopy_v1_FlexVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.AzureFile != nil {
			in, out := &in.AzureFile, &out.AzureFile
			*out = new(v1.AzureFileVolumeSource)
			**out = **in
		}
		if in.VsphereVolume != nil {
			in, out := &in.VsphereVolume, &out.VsphereVolume
			*out = new(v1.VsphereVirtualDiskVolumeSource)
			**out = **in
		}
		if in.Quobyte != nil {
			in, out := &in.Quobyte, &out.Quobyte
			*out = new(v1.QuobyteVolumeSource)
			**out = **in
		}
		if in.AzureDisk != nil {
			in, out := &in.AzureDisk, &out.AzureDisk
			*out = new(v1.AzureDiskVolumeSource)
			if err := DeepCopy_v1_AzureDiskVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PhotonPersistentDisk != nil {
			in, out := &in.PhotonPersistentDisk, &out.PhotonPersistentDisk
			*out = new(v1.PhotonPersistentDiskVolumeSource)
			**out = **in
		}
		if in.PortworxVolume != nil {
			in, out := &in.PortworxVolume, &out.PortworxVolume
			*out = new(v1.PortworxVolumeSource)
			**out = **in
		}
		if in.ScaleIO != nil {
			in, out := &in.ScaleIO, &out.ScaleIO
			*out = new(v1.ScaleIOVolumeSource)
			if err := DeepCopy_v1_ScaleIOVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeSpec)
		out := out.(*v1.PersistentVolumeSpec)
		*out = *in
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if err := DeepCopy_v1_PersistentVolumeSource(&in.PersistentVolumeSource, &out.PersistentVolumeSource, c); err != nil {
			return err
		}
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]v1.PersistentVolumeAccessMode, len(*in))
			copy(*out, *in)
		}
		if in.ClaimRef != nil {
			in, out := &in.ClaimRef, &out.ClaimRef
			*out = new(v1.ObjectReference)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_PersistentVolumeStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PersistentVolumeStatus)
		out := out.(*v1.PersistentVolumeStatus)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_PhotonPersistentDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PhotonPersistentDiskVolumeSource)
		out := out.(*v1.PhotonPersistentDiskVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Pod(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Pod)
		out := out.(*v1.Pod)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_PodSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_v1_PodStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_PodAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodAffinity)
		out := out.(*v1.PodAffinity)
		*out = *in
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = make([]v1.PodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_PodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]v1.WeightedPodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_WeightedPodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_PodAffinityTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodAffinityTerm)
		out := out.(*v1.PodAffinityTerm)
		*out = *in
		if in.LabelSelector != nil {
			in, out := &in.LabelSelector, &out.LabelSelector
			if newVal, err := c.DeepCopy(*in); err != nil {
				return err
			} else {
				*out = newVal.(*meta_v1.LabelSelector)
			}
		}
		if in.Namespaces != nil {
			in, out := &in.Namespaces, &out.Namespaces
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_PodAntiAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodAntiAffinity)
		out := out.(*v1.PodAntiAffinity)
		*out = *in
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = make([]v1.PodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_PodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]v1.WeightedPodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_WeightedPodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_PodAttachOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodAttachOptions)
		out := out.(*v1.PodAttachOptions)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_PodCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodCondition)
		out := out.(*v1.PodCondition)
		*out = *in
		out.LastProbeTime = in.LastProbeTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_PodExecOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodExecOptions)
		out := out.(*v1.PodExecOptions)
		*out = *in
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_PodList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodList)
		out := out.(*v1.PodList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.Pod, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Pod(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_PodLogOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodLogOptions)
		out := out.(*v1.PodLogOptions)
		*out = *in
		if in.SinceSeconds != nil {
			in, out := &in.SinceSeconds, &out.SinceSeconds
			*out = new(int64)
			**out = **in
		}
		if in.SinceTime != nil {
			in, out := &in.SinceTime, &out.SinceTime
			*out = new(meta_v1.Time)
			**out = (*in).DeepCopy()
		}
		if in.TailLines != nil {
			in, out := &in.TailLines, &out.TailLines
			*out = new(int64)
			**out = **in
		}
		if in.LimitBytes != nil {
			in, out := &in.LimitBytes, &out.LimitBytes
			*out = new(int64)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_PodPortForwardOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodPortForwardOptions)
		out := out.(*v1.PodPortForwardOptions)
		*out = *in
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]int32, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_PodProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodProxyOptions)
		out := out.(*v1.PodProxyOptions)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_PodSecurityContext(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodSecurityContext)
		out := out.(*v1.PodSecurityContext)
		*out = *in
		if in.SELinuxOptions != nil {
			in, out := &in.SELinuxOptions, &out.SELinuxOptions
			*out = new(v1.SELinuxOptions)
			**out = **in
		}
		if in.RunAsUser != nil {
			in, out := &in.RunAsUser, &out.RunAsUser
			*out = new(int64)
			**out = **in
		}
		if in.RunAsNonRoot != nil {
			in, out := &in.RunAsNonRoot, &out.RunAsNonRoot
			*out = new(bool)
			**out = **in
		}
		if in.SupplementalGroups != nil {
			in, out := &in.SupplementalGroups, &out.SupplementalGroups
			*out = make([]int64, len(*in))
			copy(*out, *in)
		}
		if in.FSGroup != nil {
			in, out := &in.FSGroup, &out.FSGroup
			*out = new(int64)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_PodSignature(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodSignature)
		out := out.(*v1.PodSignature)
		*out = *in
		if in.PodController != nil {
			in, out := &in.PodController, &out.PodController
			if newVal, err := c.DeepCopy(*in); err != nil {
				return err
			} else {
				*out = newVal.(*meta_v1.OwnerReference)
			}
		}
		return nil
	}
}

func DeepCopy_v1_PodSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodSpec)
		out := out.(*v1.PodSpec)
		*out = *in
		if in.Volumes != nil {
			in, out := &in.Volumes, &out.Volumes
			*out = make([]v1.Volume, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Volume(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.InitContainers != nil {
			in, out := &in.InitContainers, &out.InitContainers
			*out = make([]v1.Container, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Container(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Containers != nil {
			in, out := &in.Containers, &out.Containers
			*out = make([]v1.Container, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Container(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.TerminationGracePeriodSeconds != nil {
			in, out := &in.TerminationGracePeriodSeconds, &out.TerminationGracePeriodSeconds
			*out = new(int64)
			**out = **in
		}
		if in.ActiveDeadlineSeconds != nil {
			in, out := &in.ActiveDeadlineSeconds, &out.ActiveDeadlineSeconds
			*out = new(int64)
			**out = **in
		}
		if in.NodeSelector != nil {
			in, out := &in.NodeSelector, &out.NodeSelector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.AutomountServiceAccountToken != nil {
			in, out := &in.AutomountServiceAccountToken, &out.AutomountServiceAccountToken
			*out = new(bool)
			**out = **in
		}
		if in.SecurityContext != nil {
			in, out := &in.SecurityContext, &out.SecurityContext
			*out = new(v1.PodSecurityContext)
			if err := DeepCopy_v1_PodSecurityContext(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ImagePullSecrets != nil {
			in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
			*out = make([]v1.LocalObjectReference, len(*in))
			copy(*out, *in)
		}
		if in.Affinity != nil {
			in, out := &in.Affinity, &out.Affinity
			*out = new(v1.Affinity)
			if err := DeepCopy_v1_Affinity(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Tolerations != nil {
			in, out := &in.Tolerations, &out.Tolerations
			*out = make([]v1.Toleration, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Toleration(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_PodStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodStatus)
		out := out.(*v1.PodStatus)
		*out = *in
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]v1.PodCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_PodCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.StartTime != nil {
			in, out := &in.StartTime, &out.StartTime
			*out = new(meta_v1.Time)
			**out = (*in).DeepCopy()
		}
		if in.InitContainerStatuses != nil {
			in, out := &in.InitContainerStatuses, &out.InitContainerStatuses
			*out = make([]v1.ContainerStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ContainerStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.ContainerStatuses != nil {
			in, out := &in.ContainerStatuses, &out.ContainerStatuses
			*out = make([]v1.ContainerStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ContainerStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_PodStatusResult(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodStatusResult)
		out := out.(*v1.PodStatusResult)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_PodStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_PodTemplate(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodTemplate)
		out := out.(*v1.PodTemplate)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_PodTemplateSpec(&in.Template, &out.Template, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_PodTemplateList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodTemplateList)
		out := out.(*v1.PodTemplateList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.PodTemplate, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_PodTemplate(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_PodTemplateSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PodTemplateSpec)
		out := out.(*v1.PodTemplateSpec)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_PodSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_PortworxVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PortworxVolumeSource)
		out := out.(*v1.PortworxVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Preconditions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Preconditions)
		out := out.(*v1.Preconditions)
		*out = *in
		if in.UID != nil {
			in, out := &in.UID, &out.UID
			*out = new(types.UID)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_PreferAvoidPodsEntry(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PreferAvoidPodsEntry)
		out := out.(*v1.PreferAvoidPodsEntry)
		*out = *in
		if err := DeepCopy_v1_PodSignature(&in.PodSignature, &out.PodSignature, c); err != nil {
			return err
		}
		out.EvictionTime = in.EvictionTime.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_PreferredSchedulingTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.PreferredSchedulingTerm)
		out := out.(*v1.PreferredSchedulingTerm)
		*out = *in
		if err := DeepCopy_v1_NodeSelectorTerm(&in.Preference, &out.Preference, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_Probe(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Probe)
		out := out.(*v1.Probe)
		*out = *in
		if err := DeepCopy_v1_Handler(&in.Handler, &out.Handler, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_ProjectedVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ProjectedVolumeSource)
		out := out.(*v1.ProjectedVolumeSource)
		*out = *in
		if in.Sources != nil {
			in, out := &in.Sources, &out.Sources
			*out = make([]v1.VolumeProjection, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_VolumeProjection(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_QuobyteVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.QuobyteVolumeSource)
		out := out.(*v1.QuobyteVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_RBDVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.RBDVolumeSource)
		out := out.(*v1.RBDVolumeSource)
		*out = *in
		if in.CephMonitors != nil {
			in, out := &in.CephMonitors, &out.CephMonitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(v1.LocalObjectReference)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_RangeAllocation(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.RangeAllocation)
		out := out.(*v1.RangeAllocation)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make([]byte, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_ReplicationController(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ReplicationController)
		out := out.(*v1.ReplicationController)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_ReplicationControllerSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_v1_ReplicationControllerStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_ReplicationControllerCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ReplicationControllerCondition)
		out := out.(*v1.ReplicationControllerCondition)
		*out = *in
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_ReplicationControllerList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ReplicationControllerList)
		out := out.(*v1.ReplicationControllerList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.ReplicationController, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ReplicationController(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_ReplicationControllerSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ReplicationControllerSpec)
		out := out.(*v1.ReplicationControllerSpec)
		*out = *in
		if in.Replicas != nil {
			in, out := &in.Replicas, &out.Replicas
			*out = new(int32)
			**out = **in
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.Template != nil {
			in, out := &in.Template, &out.Template
			*out = new(v1.PodTemplateSpec)
			if err := DeepCopy_v1_PodTemplateSpec(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_ReplicationControllerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ReplicationControllerStatus)
		out := out.(*v1.ReplicationControllerStatus)
		*out = *in
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]v1.ReplicationControllerCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ReplicationControllerCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_ResourceFieldSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ResourceFieldSelector)
		out := out.(*v1.ResourceFieldSelector)
		*out = *in
		out.Divisor = in.Divisor.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_ResourceQuota(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ResourceQuota)
		out := out.(*v1.ResourceQuota)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_ResourceQuotaSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_v1_ResourceQuotaStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_ResourceQuotaList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ResourceQuotaList)
		out := out.(*v1.ResourceQuotaList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.ResourceQuota, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ResourceQuota(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_ResourceQuotaSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ResourceQuotaSpec)
		out := out.(*v1.ResourceQuotaSpec)
		*out = *in
		if in.Hard != nil {
			in, out := &in.Hard, &out.Hard
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Scopes != nil {
			in, out := &in.Scopes, &out.Scopes
			*out = make([]v1.ResourceQuotaScope, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_ResourceQuotaStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ResourceQuotaStatus)
		out := out.(*v1.ResourceQuotaStatus)
		*out = *in
		if in.Hard != nil {
			in, out := &in.Hard, &out.Hard
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Used != nil {
			in, out := &in.Used, &out.Used
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

func DeepCopy_v1_ResourceRequirements(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ResourceRequirements)
		out := out.(*v1.ResourceRequirements)
		*out = *in
		if in.Limits != nil {
			in, out := &in.Limits, &out.Limits
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		if in.Requests != nil {
			in, out := &in.Requests, &out.Requests
			*out = make(v1.ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		}
		return nil
	}
}

func DeepCopy_v1_SELinuxOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.SELinuxOptions)
		out := out.(*v1.SELinuxOptions)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ScaleIOVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ScaleIOVolumeSource)
		out := out.(*v1.ScaleIOVolumeSource)
		*out = *in
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(v1.LocalObjectReference)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_Secret(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Secret)
		out := out.(*v1.Secret)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make(map[string][]byte)
			for key, val := range *in {
				if newVal, err := c.DeepCopy(&val); err != nil {
					return err
				} else {
					(*out)[key] = *newVal.(*[]byte)
				}
			}
		}
		if in.StringData != nil {
			in, out := &in.StringData, &out.StringData
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		return nil
	}
}

func DeepCopy_v1_SecretEnvSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.SecretEnvSource)
		out := out.(*v1.SecretEnvSource)
		*out = *in
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_SecretKeySelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.SecretKeySelector)
		out := out.(*v1.SecretKeySelector)
		*out = *in
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_SecretList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.SecretList)
		out := out.(*v1.SecretList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.Secret, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Secret(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_SecretProjection(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.SecretProjection)
		out := out.(*v1.SecretProjection)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_SecretVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.SecretVolumeSource)
		out := out.(*v1.SecretVolumeSource)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		}
		if in.Optional != nil {
			in, out := &in.Optional, &out.Optional
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_SecurityContext(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.SecurityContext)
		out := out.(*v1.SecurityContext)
		*out = *in
		if in.Capabilities != nil {
			in, out := &in.Capabilities, &out.Capabilities
			*out = new(v1.Capabilities)
			if err := DeepCopy_v1_Capabilities(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Privileged != nil {
			in, out := &in.Privileged, &out.Privileged
			*out = new(bool)
			**out = **in
		}
		if in.SELinuxOptions != nil {
			in, out := &in.SELinuxOptions, &out.SELinuxOptions
			*out = new(v1.SELinuxOptions)
			**out = **in
		}
		if in.RunAsUser != nil {
			in, out := &in.RunAsUser, &out.RunAsUser
			*out = new(int64)
			**out = **in
		}
		if in.RunAsNonRoot != nil {
			in, out := &in.RunAsNonRoot, &out.RunAsNonRoot
			*out = new(bool)
			**out = **in
		}
		if in.ReadOnlyRootFilesystem != nil {
			in, out := &in.ReadOnlyRootFilesystem, &out.ReadOnlyRootFilesystem
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_SerializedReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.SerializedReference)
		out := out.(*v1.SerializedReference)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Service(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Service)
		out := out.(*v1.Service)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if err := DeepCopy_v1_ServiceSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_v1_ServiceStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_ServiceAccount(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ServiceAccount)
		out := out.(*v1.ServiceAccount)
		*out = *in
		if newVal, err := c.DeepCopy(&in.ObjectMeta); err != nil {
			return err
		} else {
			out.ObjectMeta = *newVal.(*meta_v1.ObjectMeta)
		}
		if in.Secrets != nil {
			in, out := &in.Secrets, &out.Secrets
			*out = make([]v1.ObjectReference, len(*in))
			copy(*out, *in)
		}
		if in.ImagePullSecrets != nil {
			in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
			*out = make([]v1.LocalObjectReference, len(*in))
			copy(*out, *in)
		}
		if in.AutomountServiceAccountToken != nil {
			in, out := &in.AutomountServiceAccountToken, &out.AutomountServiceAccountToken
			*out = new(bool)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_ServiceAccountList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ServiceAccountList)
		out := out.(*v1.ServiceAccountList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.ServiceAccount, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_ServiceAccount(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_ServiceList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ServiceList)
		out := out.(*v1.ServiceList)
		*out = *in
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]v1.Service, len(*in))
			for i := range *in {
				if err := DeepCopy_v1_Service(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		}
		return nil
	}
}

func DeepCopy_v1_ServicePort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ServicePort)
		out := out.(*v1.ServicePort)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ServiceProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ServiceProxyOptions)
		out := out.(*v1.ServiceProxyOptions)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_ServiceSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ServiceSpec)
		out := out.(*v1.ServiceSpec)
		*out = *in
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]v1.ServicePort, len(*in))
			copy(*out, *in)
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		}
		if in.ExternalIPs != nil {
			in, out := &in.ExternalIPs, &out.ExternalIPs
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		if in.LoadBalancerSourceRanges != nil {
			in, out := &in.LoadBalancerSourceRanges, &out.LoadBalancerSourceRanges
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
		return nil
	}
}

func DeepCopy_v1_ServiceStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.ServiceStatus)
		out := out.(*v1.ServiceStatus)
		*out = *in
		if err := DeepCopy_v1_LoadBalancerStatus(&in.LoadBalancer, &out.LoadBalancer, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_Sysctl(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Sysctl)
		out := out.(*v1.Sysctl)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_TCPSocketAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.TCPSocketAction)
		out := out.(*v1.TCPSocketAction)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_Taint(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Taint)
		out := out.(*v1.Taint)
		*out = *in
		out.TimeAdded = in.TimeAdded.DeepCopy()
		return nil
	}
}

func DeepCopy_v1_Toleration(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Toleration)
		out := out.(*v1.Toleration)
		*out = *in
		if in.TolerationSeconds != nil {
			in, out := &in.TolerationSeconds, &out.TolerationSeconds
			*out = new(int64)
			**out = **in
		}
		return nil
	}
}

func DeepCopy_v1_Volume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.Volume)
		out := out.(*v1.Volume)
		*out = *in
		if err := DeepCopy_v1_VolumeSource(&in.VolumeSource, &out.VolumeSource, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_v1_VolumeMount(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.VolumeMount)
		out := out.(*v1.VolumeMount)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_VolumeProjection(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.VolumeProjection)
		out := out.(*v1.VolumeProjection)
		*out = *in
		if in.Secret != nil {
			in, out := &in.Secret, &out.Secret
			*out = new(v1.SecretProjection)
			if err := DeepCopy_v1_SecretProjection(*in, *out, c); err != nil {
				return err
			}
		}
		if in.DownwardAPI != nil {
			in, out := &in.DownwardAPI, &out.DownwardAPI
			*out = new(v1.DownwardAPIProjection)
			if err := DeepCopy_v1_DownwardAPIProjection(*in, *out, c); err != nil {
				return err
			}
		}
		if in.ConfigMap != nil {
			in, out := &in.ConfigMap, &out.ConfigMap
			*out = new(v1.ConfigMapProjection)
			if err := DeepCopy_v1_ConfigMapProjection(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_VolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.VolumeSource)
		out := out.(*v1.VolumeSource)
		*out = *in
		if in.HostPath != nil {
			in, out := &in.HostPath, &out.HostPath
			*out = new(v1.HostPathVolumeSource)
			**out = **in
		}
		if in.EmptyDir != nil {
			in, out := &in.EmptyDir, &out.EmptyDir
			*out = new(v1.EmptyDirVolumeSource)
			**out = **in
		}
		if in.GCEPersistentDisk != nil {
			in, out := &in.GCEPersistentDisk, &out.GCEPersistentDisk
			*out = new(v1.GCEPersistentDiskVolumeSource)
			**out = **in
		}
		if in.AWSElasticBlockStore != nil {
			in, out := &in.AWSElasticBlockStore, &out.AWSElasticBlockStore
			*out = new(v1.AWSElasticBlockStoreVolumeSource)
			**out = **in
		}
		if in.GitRepo != nil {
			in, out := &in.GitRepo, &out.GitRepo
			*out = new(v1.GitRepoVolumeSource)
			**out = **in
		}
		if in.Secret != nil {
			in, out := &in.Secret, &out.Secret
			*out = new(v1.SecretVolumeSource)
			if err := DeepCopy_v1_SecretVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.NFS != nil {
			in, out := &in.NFS, &out.NFS
			*out = new(v1.NFSVolumeSource)
			**out = **in
		}
		if in.ISCSI != nil {
			in, out := &in.ISCSI, &out.ISCSI
			*out = new(v1.ISCSIVolumeSource)
			if err := DeepCopy_v1_ISCSIVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Glusterfs != nil {
			in, out := &in.Glusterfs, &out.Glusterfs
			*out = new(v1.GlusterfsVolumeSource)
			**out = **in
		}
		if in.PersistentVolumeClaim != nil {
			in, out := &in.PersistentVolumeClaim, &out.PersistentVolumeClaim
			*out = new(v1.PersistentVolumeClaimVolumeSource)
			**out = **in
		}
		if in.RBD != nil {
			in, out := &in.RBD, &out.RBD
			*out = new(v1.RBDVolumeSource)
			if err := DeepCopy_v1_RBDVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.FlexVolume != nil {
			in, out := &in.FlexVolume, &out.FlexVolume
			*out = new(v1.FlexVolumeSource)
			if err := DeepCopy_v1_FlexVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Cinder != nil {
			in, out := &in.Cinder, &out.Cinder
			*out = new(v1.CinderVolumeSource)
			**out = **in
		}
		if in.CephFS != nil {
			in, out := &in.CephFS, &out.CephFS
			*out = new(v1.CephFSVolumeSource)
			if err := DeepCopy_v1_CephFSVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.Flocker != nil {
			in, out := &in.Flocker, &out.Flocker
			*out = new(v1.FlockerVolumeSource)
			**out = **in
		}
		if in.DownwardAPI != nil {
			in, out := &in.DownwardAPI, &out.DownwardAPI
			*out = new(v1.DownwardAPIVolumeSource)
			if err := DeepCopy_v1_DownwardAPIVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.FC != nil {
			in, out := &in.FC, &out.FC
			*out = new(v1.FCVolumeSource)
			if err := DeepCopy_v1_FCVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.AzureFile != nil {
			in, out := &in.AzureFile, &out.AzureFile
			*out = new(v1.AzureFileVolumeSource)
			**out = **in
		}
		if in.ConfigMap != nil {
			in, out := &in.ConfigMap, &out.ConfigMap
			*out = new(v1.ConfigMapVolumeSource)
			if err := DeepCopy_v1_ConfigMapVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.VsphereVolume != nil {
			in, out := &in.VsphereVolume, &out.VsphereVolume
			*out = new(v1.VsphereVirtualDiskVolumeSource)
			**out = **in
		}
		if in.Quobyte != nil {
			in, out := &in.Quobyte, &out.Quobyte
			*out = new(v1.QuobyteVolumeSource)
			**out = **in
		}
		if in.AzureDisk != nil {
			in, out := &in.AzureDisk, &out.AzureDisk
			*out = new(v1.AzureDiskVolumeSource)
			if err := DeepCopy_v1_AzureDiskVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PhotonPersistentDisk != nil {
			in, out := &in.PhotonPersistentDisk, &out.PhotonPersistentDisk
			*out = new(v1.PhotonPersistentDiskVolumeSource)
			**out = **in
		}
		if in.Projected != nil {
			in, out := &in.Projected, &out.Projected
			*out = new(v1.ProjectedVolumeSource)
			if err := DeepCopy_v1_ProjectedVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		if in.PortworxVolume != nil {
			in, out := &in.PortworxVolume, &out.PortworxVolume
			*out = new(v1.PortworxVolumeSource)
			**out = **in
		}
		if in.ScaleIO != nil {
			in, out := &in.ScaleIO, &out.ScaleIO
			*out = new(v1.ScaleIOVolumeSource)
			if err := DeepCopy_v1_ScaleIOVolumeSource(*in, *out, c); err != nil {
				return err
			}
		}
		return nil
	}
}

func DeepCopy_v1_VsphereVirtualDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.VsphereVirtualDiskVolumeSource)
		out := out.(*v1.VsphereVirtualDiskVolumeSource)
		*out = *in
		return nil
	}
}

func DeepCopy_v1_WeightedPodAffinityTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*v1.WeightedPodAffinityTerm)
		out := out.(*v1.WeightedPodAffinityTerm)
		*out = *in
		if err := DeepCopy_v1_PodAffinityTerm(&in.PodAffinityTerm, &out.PodAffinityTerm, c); err != nil {
			return err
		}
		return nil
	}
}
